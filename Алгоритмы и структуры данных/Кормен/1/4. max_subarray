#include "profile.h"

#include <algorithm>
#include <iostream>
#include <vector>
#include <iterator>
#include <tuple>

template <typename It> tuple<int, It, It> max_subar_n2(It begin, It end) // O(n^2)
{
	if (distance(begin, end) > 0)
	{
		int result = INT_MIN;
		It left, right;
		for (; begin != end; ++begin)
		{
			int sum = 0;
			for (It i = begin; i != end; ++i)
			{
				sum += *i;
				if (sum > result)
				{
					result = sum;
					left = begin;
					right = next(i);
				}
			}
		}
		return make_tuple(result, left, right);
	}
	return make_tuple(0, begin, end);
}

template <typename It> tuple<int, It, It> max_cross_subarray(It begin, It mid, It end)
{
	It max_left, max_right;
	int left_sum = INT_MIN;
	int sum = 0;
	for (It i = mid; i != begin; )
	{
		--i;
		sum += *i;
		if (sum > left_sum)
		{
			left_sum = sum;
			max_left = i;
		}
	}

	int right_sum = INT_MIN;
	sum = 0;
	for (It i = mid; i != end; ++i)
	{
		sum += *i;
		if (sum > right_sum)
		{
			right_sum = sum;
			max_right = next(i);
		}
	}
	return make_tuple(left_sum + right_sum, max_left, max_right);
}

template <typename It> tuple<int, It, It> max_subarray(It begin, It end) // O(nlogn)
{
	if (distance(begin, end) == 1)
	{
		return { *begin, begin, end };
	}
	else if (distance(begin, end) > 1)
	{
		It mid = begin + distance(begin, end) / 2;
		tuple<int, It, It> left = max_subarray(begin, mid);
		tuple<int, It, It> right = max_subarray(mid, end);
		tuple<int, It, It> cross = max_cross_subarray(begin, mid, end);
		if (left >= right && left >= cross)
		{
			return left;
		}
		else if (right >= left && right >= cross)
		{
			return right;
		}
		else
		{
			return cross;
		}
	}
	return make_tuple(0, begin, end);
}

template<typename It> tuple<int, It, It> max_subar_linear(It first, It last)
{
	It left = first;
	It right = first;
	It tmp_left = first;
	int sum = INT_MIN;
	int tmp_sum = 0;
	for (; first != last; ++first)
	{
		tmp_sum = max(tmp_sum + *first, *first);
		if (tmp_sum > sum)
		{
			sum = tmp_sum;
			right = first;
			left = tmp_left;
		}
		if (tmp_sum == *first)
		{
			tmp_left = first;
		}
	}
	return { sum, left, right };
}

int main() {
	//vector<int> ar = { 13, -3, -25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4, 7 };
	vector<int> ar;
	const size_t N = 25000;
	ar.reserve(N);
	srand(unsigned(time(0)));
	for (size_t i = 0; i < N; ++i)
	{
		ar.emplace_back(rand() % 101 - 50);
	}

	{
		LOG_DURATION("N^2");
		auto res1 = max_subar_n2(ar.begin(), ar.end());
		cout << get<0>(res1) << endl;
	}

	{
		LOG_DURATION("logN");
		auto res1 = max_subarray(ar.begin(), ar.end());
		cout << get<0>(res1) << endl;
	}

	{
		LOG_DURATION("N");
		auto res1 = max_subar_linear(ar.begin(), ar.end());
		cout << get<0>(res1) << endl;
	}

	/*
		1000		10000		25000
	N^2:	72 ms		7261 ms		44521 ms
	logN:	9 ms		93 ms		238 ms
	N:	0 ms		2 ms		5 ms
	*/

	return 0;
}

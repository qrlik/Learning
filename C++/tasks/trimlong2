#include <iostream>
#include <string_view>
#include <algorithm>
#include <optional>
using namespace std;

#include "test_runner.h"
#include "profile.h"

/*
Напишите функцию, которая обрезает пробелы в конце переданной ей строки.
Функция должна быть написана в расчёте на работу с очень длинными строками с очень большим количеством пробелов, оптимизирована по количеству обращений к памяти.
Сигнатура: void TrimRight( char *s );
*/

bool checkZeroByte(const int* ptr) // проверка на нулевой байт
{
	const char* pbyte = reinterpret_cast<const char*>(ptr);
	for (size_t i = 0; i < sizeof(int); ++i)
	{
		if (pbyte[i] == 0)
		{
			return true;
		}
	}
	return false;
}

enum is_empty_suffix
{
	TRUE,
	FALSE
};

pair<char*, is_empty_suffix> FindSpaceSuffix(int* ptr) // поиск позиции суффикса из пробелов
{
	char* pbyte = reinterpret_cast<char*>(ptr);
	char* pos = nullptr;
	size_t i = 0;
	for (; i < sizeof(int) && *pbyte != 0; ++pbyte, ++i)
	{
		if (*pbyte == ' ') {
			if (!pos) {
				pos = pbyte;
			}
		}
		else {
			pos = nullptr;
		}
	}
	if (i == 0) {
		return { pos, is_empty_suffix::TRUE };
	}
	return { pos, is_empty_suffix::FALSE };
}

void TrimRight(char* s) {
	if (!s) {
		return;
	}

	int mask = *reinterpret_cast<int*>(string(4, ' ').data()); // маска из пробелов

	int* ptr = reinterpret_cast<int*>(s);
	int* space_suffix = nullptr;

	for (; ; ++ptr) {
		if (*ptr == mask) {
			if (!space_suffix) {
				space_suffix = ptr;
			}
		}
		else {
			if (!checkZeroByte(ptr)) { 
				space_suffix = nullptr;
			}
			else {
				break;
			}
		}
	}
	// условно делим данные на часть слева от ptr и справа (хвостик с нулевым байтом)

	pair<char*, is_empty_suffix> left_suffix = { nullptr, is_empty_suffix::TRUE };
	if (space_suffix) {
		if (space_suffix != reinterpret_cast<int*>(s)) {
			left_suffix = FindSpaceSuffix(space_suffix - 1);
		}
		else {
			left_suffix = { s, is_empty_suffix::FALSE };
		}
	}
	else {
		if (ptr != reinterpret_cast<int*>(s)) {
			left_suffix = FindSpaceSuffix(ptr - 1);
		}
	}

	pair<char*, is_empty_suffix> right_suffix = FindSpaceSuffix(ptr);

	if (left_suffix.first && (right_suffix.first == reinterpret_cast<char*>(ptr) || right_suffix.second == is_empty_suffix::TRUE))
	{
		*left_suffix.first = 0;
	}
	else if ((left_suffix.first && right_suffix.first && right_suffix.second == is_empty_suffix::FALSE) ||
		(!left_suffix.first && right_suffix.first))
	{
		right_suffix.first = 0;
	}
}

void TrimRightStrlen(char* s) {
	if (!s) {
		return;
	}

	size_t len = strlen(s);
	for (; len > 0; --len) {
		if (s[len - 1] != ' ') {
			break;
		}
	}
	s[len] = '\0';
}

void TrimRightFor(char* s) {
	if (!s) {
		return;
	}

	char* last_space = nullptr;
	for (; *s != '\0'; ++s)
	{
		if (*s == ' ') {
			if (!last_space) {
				last_space = s;
			}
		}
		else {
			last_space = nullptr;
		}
	}

	if (last_space) {
		*last_space = '\0';
	}
}

void TrimRightWhile(char* s) {
	if (!s) {
		return;
	}

	char* last_space = nullptr;
	char symbol = *s;

	while (symbol != '\0') {
		if (*s == ' ') {
			if (!last_space) {
				last_space = s;
			}
		}
		else if (symbol != ' ') {
			last_space = nullptr;
		}
		++s;
		symbol = *s;
	}

	if (last_space) {
		*last_space = '\0';
	}
}

template<typename Func>
void TestTrimTemplate(Func f)
{
	string test = "a b c   ";
	string test2 = "                  a";
	string test3 = "a                  ";
	string test4 = "                  ";
	string test5 = "a";
	string test6 = "";
	f(test.data());
	f(test2.data());
	f(test3.data());
	f(test4.data());
	f(test5.data());
	f(test6.data());

	string test_check = "a b c";
	string test2_check = "                  a";
	string test3_check = "a";
	string test4_check = "";
	string test5_check = "a";
	string test6_check = "";
	ASSERT_EQUAL(test.data(), test_check);
	ASSERT_EQUAL(test2.data(), test2_check);
	ASSERT_EQUAL(test3.data(), test3_check);
	ASSERT_EQUAL(test4.data(), test4_check);
	ASSERT_EQUAL(test5.data(), test5_check);
	ASSERT_EQUAL(test6.data(), test6_check);
}

void TestTrimRight()
{
	TestTrimTemplate(TrimRight);
}

void TestTrimRightStrlen()
{
	TestTrimTemplate(TrimRightStrlen);
}

void TestTrimRightFor()
{
	TestTrimTemplate(TrimRightFor);
}

void TestTrimRightWhile()
{
	TestTrimTemplate(TrimRightWhile);
}

void TestAll()
{
	TestRunner tr;
	RUN_TEST(tr, TestTrimRight);
	RUN_TEST(tr, TestTrimRightStrlen);
	RUN_TEST(tr, TestTrimRightFor);
	RUN_TEST(tr, TestTrimRightWhile);
}

int main()
{
	TestAll();

	{
		LOG_DURATION("String_view");
		string test(1'000'000'000, ' ');
		TrimRight(test.data());
		cout << "SV result is '" << test.data() << "'" << endl;
	}

	{
		LOG_DURATION("Strlen");
		string test(1'000'000'000, ' ');
		TrimRightStrlen(test.data());
		cout << "Strlen result is '" << test.data() << "'" << endl;
	}

	{
		LOG_DURATION("For");
		string test(1'000'000'000, ' ');
		TrimRightFor(test.data());
		cout << "For result is '" << test.data() << "'" << endl;
	}

	{
		LOG_DURATION("While");
		string test(1'000'000'000, ' ');
		TrimRightWhile(test.data());
		cout << "While result is '" << test.data() << "'" << endl;
	}
	return 0;
}

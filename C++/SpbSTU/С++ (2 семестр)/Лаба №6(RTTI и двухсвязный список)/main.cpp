/*	RTTI
Создать класс, реализующий объектно-ориентированный список для объектов, производных от одного и того же базового класса.
	1.	Создайте базовый класс Shape и производные от него классы Rect, Circle…
Подумайте, какие методы и переменные должны быть определены (переопределены) в каждом из этих классе. Обратите внимание на спецификаторы доступа и «виртуальность» методов.
Предусмотрите возможность вычисления площади для объекта каждого производного класса.
	2.	Механизм RTTI
Так как объекты могут быть разного типа, Вам понадобиться определение действительного типа объекта во время выполнения.
	3.	Разработаем двухсвязный список, элементы которого будут являться копиями наших объектов
Замечание: так как в списке будут фигурировать копии объектов – нам все равно, каким образом объекты-оригиналы были созданы (глобальные, локальные, динамические, автоматические неименованные) => манипулируя списком, мы несем ответственность только за уничтожение копий, а оригиналы создаются и уничтожаются независимо.
Список реализуется двумя классами:
	4.	Сортировка
Напишите для класса List сортировку по возрастанию площади объекта (по цвету, по удалению от начала координат…).
	5.	Вывод списка в файл и чтение из файла
*/

#include "list.h"
#define	  stop __asm nop

int main()
{
	// отладка
	Circle c1;
	Circle* pc2 = new Circle(1, 2, 3, RED);
	Rect r1;
	Rect* pr2 = new Rect(3, 4, 2, 1, GREEN);

	List list; // заносим в объект копии
	list.addToTail(c1);
	list.addToTail(*pr2);
	delete pr2;
	list.addToHead(r1);
	list.addToHead(*pc2);
	delete pc2;
	stop // m_size 4

	std::cout << list << std::endl;
	stop
	/*
	1. Circle: (1, 2, 3, 0)
	2. Rect: (0, 0, 0, 0, 1)
	3. Circle: (0, 0, 0, 2)
	4. Rect: (3, 4, 2, 1, 1)
	*/
	list.sort(0); // color
	std::cout << list << std::endl;
	stop
	/*
	1. Circle: (1, 2, 3, 0)
	2. Rect: (0, 0, 0, 0, 1)
	3. Rect: (3, 4, 2, 1, 1)
	4. Circle: (0, 0, 0, 2)
	*/
	list.writeToFile("file.txt");
	list.readFromFile("file.txt");
	std::cout << list << std::endl;
	stop
	/*
	1. Circle: (1, 2, 3, 0)
	2. Rect: (0, 0, 0, 0, 1)
	3. Rect: (3, 4, 2, 1, 1)
	4. Circle: (0, 0, 0, 2)
	5. Circle: (1, 2, 3, 0)
	6. Rect: (0, 0, 0, 0, 1)
	7. Rect: (3, 4, 2, 1, 1)
	8. Circle: (0, 0, 0, 2)
	*/
	list.sort(2); // square
	std::cout << list << std::endl;
	stop
	/*
	1. Rect: (0, 0, 0, 0, 1)
	2. Circle: (0, 0, 0, 2)
	3. Rect: (0, 0, 0, 0, 1)
	4. Circle: (0, 0, 0, 2)
	5. Rect: (3, 4, 2, 1, 1)
	6. Rect: (3, 4, 2, 1, 1)
	7. Circle: (1, 2, 3, 0)
	8. Circle: (1, 2, 3, 0)
	*/
	return 0;
}

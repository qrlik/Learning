#include "rectangle.h"
#include "string.h"
#include "bochka.h"
#include <iostream>

#define stop __asm nop

int main()
{
	using namespace std;
	//Задание 1.Объявление класса. Создание экземпляра класса.
	//Вызов методов класса. 
	//Откройте закладку Class View - (здесь Вы увидите имена методов и
	//данных - классов Rect и MyString)
	//Обратите внимание на пиктограммы слева от имен членов класса - они
	//обозначают спецификатор доступа к каждому члену класса.

	//Какой конструктор вызывается при создании экземпляра класса?
	{
		Rect rect;
		stop
	}

	//1a. Объявите и определите конструктор с параметрами для
	//инициализации переменных класса. Создайте экземляры класса Rect
	//с помощью конструктора с параметрами. Если компилятор выдает
	//ошибку в предыдущем фрагменте, подумайте - чего ему не
	//хватает? Добейтесь отсутствия ошибок.
	//Выполняя задание с самого начала по шагам, определите:
	//в какой момент происходит вызов конструктора(какого?)?

	Rect rect(1, 3, 1, 4);

	stop
	//1б. При конструировании объекта посредством конструктора без параметров
	//предусмотрите инициализацию переменных класса, например, нулем


	//1в. Подумайте, как следует поступать в случае, когда пользователь задал
	//координаты следующим образом:

	//rect::checkPoints()
	Rect rrr(4, 3, 2, 1);

	stop
	//1г. Объявите, определите и вызовите метод класса InflateRect(), 
	//который увеличивает размеры прямоугольника на заданные приращения
	//(раздвигая стороны от центра - каждую сторону на свое значение).
	//Подсказка: объявить и определить методы можно не только "вручную",
	//но и с помощью Wizard-a Class View. Для этого: откройте закладку
	//ClassView окна проекта, сделайте активным класс Rect и нажмите
	//правую кнопку мыши - в появившемся контекстном меню выберите
	//Add/Add Member Function... С помощью появившейся диалоговой панели
	//"дайте указания" Wizard-у как объявить и определить метод.

	stop

	//Задание 2.Перегрузка конструкторов и методов класса.
	//Конструктор копирования.

	//2а.Объявите и определите конструктор копирования в классе Rect.
	//Выполняя задание по шагам, определите, какой
	//конструктор вызывается при создании r1,r2,r3 и r4?
	//Чему равны переменные созданных объектов?
	Rect r1; // 1
	Rect r2(1, 2, 3, 4); // 2
	Rect r3 = r1; // 3
	Rect r4(r2); // 3
	stop

	//2б. Объявите и определите в классе Rect метод InflateRect(),
	//который принимает два аргумента, по умолчанию равных 1, и 
	//раздвигает стороны прямоугольника на на заданные приращения.
	//Для каких объектов вызывается функция InflateRect()?
	r1.InflateRect(1, 1); //r1
	r2.InflateRect(2, 2); //r2
	//Какая из функций InflateRect() вызывается в каждом из трех случаев?
	r3.InflateRect(2, 2, 2, 2); //1
	r3.InflateRect(3, 3); //2
	r3.InflateRect(5); //2
	r3.InflateRect(); //2
	stop

	//Задание 3.Спецификаторы доступа. Инкапсуляция. 
	{
		Rect r;
	//Раскомментируйте следующую строку. Объясните ошибку
	//компилятора

	//	int tmp = r.m_left;

	//Введите в класс Rect метод void SetAll(...),
	//который присваивают переменным класса передаваемые
	//значения. Вызовите созданный метод, проверьте корректность. 

	//Введите в класс Rect парный метод GetAll(...),
	//который "достает" значения private-переменных класса.
	//Вызовите созданный метод, проверьте корректность. 

		stop
	}

	//Задание 4.Передача экземпляра класса в качестве параметра
	//функции. Возвращение объекта класса по значению. Поставив
	//остановы в конструкторе копирования или выполняя фрагмент
	//по шагам, определите: в какой момент происходит обращение
	//к конструктору копирования. 
	//Создайте глобальную функцию 
	// Rect BoundingRect(Rect, Rect);
	//которая принимает два объекта класса Rect по значению и
	//возвращает объект класса Rect, который является прямоугольником,
	//в который вписаны заданные прямоугольники. Как происходит
	//передача параметров и возвращение объекта класса?

	//Замечание*: хорошо было бы учесть тот факт, что прямоугольник
	//может оказаться "ненормализованным", то есть m_left>m_right или/и
	//m_top>m_bottom

	{
		Rect r1(1, 2, 3, 4), r2(5, 6, 7, 8), r3;
		r3 = BoundingRect(r1, r2); // 3 times
		stop

		//Задание 4а. Передача объектов по ссылке.
		//Создайте глобальную функцию BoundingRect2, которая выполняет ту же
		//задачу, принимая параметры по ссылке
		//Вызываются ли конструкторы при передаче параметров?

		r3 = BoundingRect2(r1, r2); // 1 time
		stop
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		r3.BoundingRect3(r1, r2); // 0 time
		stop
	}

	//Задание 5. Указатель на класс. Объявите и определите
	//явный деструктор класса. Поставьте остановы в 
	//конструкторе (конструкторах) и деструкторе. Определите: когда для
	//каждого из объектов вызывается конструктор, а когда - деструктор?
	{
		Rect r1; // const 1
		Rect* pR = new Rect(1, 2, 1, 2); // const 2
		{
			Rect r2(r1); // const 3
			Rect arRect[2]; // const 1 x2
			for (int i = 0; i < 3; i++)
			{
				static Rect r3(i, i, i, i); // const 2 x1
				Rect r4(*pR); // const 3 x3
				Rect r5(i, i, i, i); // const 2 x3
			} // destr x2/x2/x3
		} // destr x3
		delete pR; // destr
		stop
	} // destr

	  //Задание 6.Конструктор + деструктор = функциональное
	  // замыкание. Класс MyString
	  // Посредством конструктора (конструкторов) и деструктора обеспечьте
	  //корректные инициализацию и деактивацию объекта
	  //C помощью остановов определите когда происходит
	  //захват и освобождение памяти для строки-члена класса

	{
		MyString str("It's my string!"); // new
		//Создайте метод GetString(), который обеспечит доступ к хранящейся строке.
		//С помощью cout и метода GetString() распечатайте строку объекта str
		//Замечание: подумайте, как следует корректно реализовать метод GetString().
		cout << str.getString() << endl;
	} // delete
	stop

	//6a. Раскомментируйте следующий фрагмент. Подумайте - какие
	//неприятности Вас ожидают. Попробуйте исправить положение (как?)
	{
		MyString str1("The first string!");
		MyString str2 = str1; // при удалении str1, указатель str2 будет указывать на освобожденный участок памяти.
	}
	stop

	//6б. Реализуйте метод SetNewString, который будет заменять строку
	// на новую
	{
		MyString str1("The!");
		str1.setString("New string");
		stop
	}

	//6г. Создайте глобальную функцию, которая будет принимать любое
	//количество указателей на строки, а возвращать объект MyString,
	//в котором строка будет конкатенацией параметров

	MyString test6g = connectString("Hey", "Hello", "this is my last words", nullptr); 
	stop

	//Задание 7.Массив объектов класса.
	{
		//Объявите и проинициализируйте массив ar из объектов
		// типа MyString. Например:
		//Как задать размерность? N=3
		const size_t N = 5;
		MyString arstr[N] = { MyString(), MyString("Second string"), MyString(test6g) };

		//Проверка - печать строк-членов класса
		for (size_t i = 0; i < N; i++)
		{
			printf("%s\n", arstr[i].getString());
		}

		//Объявите и проинициализируйте массив объектов	типа Rect.

		Rect arect[N] = { Rect(), Rect(1,2,3,4), Rect(rrr) };
		stop
	}
	stop

	//Задание 8.Массив указателей на объекты класса.
	{
		//Объявите и проинициализируйте массив arPtr из трех
		//указателей на объекты типа MyString.
		MyString* arPtr[5] = { new MyString(), new MyString(), new MyString("Third") };

		//Печать строк-членов класса
		for (size_t i = 0; i < 5; i++)
		{
			printf("%s\n", arPtr[i]->getString()); // ошибка если указатель nullptr, как лучше предусматривать? - Добавить if (!this)
		}
		for (size_t i = 0; i < 5; i++)
		{
			delete arPtr[i];
		}
	}
	stop

	//Задание 9.  Решите с помощью классов следующую задачу:
	//даны две бочки известного объема. В одной бочке в начальный момент
	//времени содержится спирт (96%), в другой – вода.
	//Кружкой емкостью 1л переливаем итеративно содержимое из одной бочки
	//в другую следующим способом: на каждой итерации
	//зачерпнули из первой бочки -> вылили во вторую
	//зачерпнули из второй бочки -> вылили в первую.
	//Требуется определить номер итерации, на которой концентрация спирта в
	//первой бочке станет меньше 50%.

	double V = 100;
	Bochka spirt(V, 0.96);
	Bochka water(V, 0);
	size_t count = 0;
	while(spirt.getConc() > 0.5)
	{
		spirt.pereliv(water); //или spirt.Pereliv(water, объем_кружки);
		water.pereliv(spirt); // аналогично
		count++;
	}
	printf("Iteration number is %d\n", count);
	return 0;
}//end_main

